//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

import WebKit

// MARK: - Wallet Data Structures

/// Wallet address information
public struct BitcoinAddresses: Codable {
    public let legacy: String
    public let segwit: String
    public let taproot: String
    
    public init(legacy: String, segwit: String, taproot: String) {
        self.legacy = legacy
        self.segwit = segwit
        self.taproot = taproot
    }
    
    /// Initialize from dictionary (for parsing JS returned data)
    public init?(from dictionary: [String: Any]) {
        guard let legacy = dictionary["legacy"] as? String,
              let segwit = dictionary["segwit"] as? String,
              let taproot = dictionary["taproot"] as? String else {
            return nil
        }
        self.legacy = legacy
        self.segwit = segwit
        self.taproot = taproot
    }
}

/// Wallet information data model
/// Used to receive wallet information generated by JS
public struct BitcoinWallet_V1: Codable {
    /// Network type: "mainnet" or "testnet"
    public let network: String
    
    /// Mnemonic length (only when generating wallet): 128/160/192/224/256, corresponding to 12/15/18/21/24 words
    public let mnemonicLength: Int?
    
    /// Mnemonic (12 or 24 words, space-separated)
    /// May be nil when importing from private key
    public let mnemonic: String?
    
    /// Private key (64 hexadecimal characters)
    public let privateKey: String
    
    /// Public key (66 hexadecimal characters, compressed format)
    public let publicKey: String
    
    /// Address information (includes Legacy, Segwit, and Taproot addresses)
    public let addresses: BitcoinAddresses
    
    public init(network: String, 
                mnemonicLength: Int? = nil,
                mnemonic: String?,
                privateKey: String,
                publicKey: String,
                addresses: BitcoinAddresses) {
        self.network = network
        self.mnemonicLength = mnemonicLength
        self.mnemonic = mnemonic
        self.privateKey = privateKey
        self.publicKey = publicKey
        self.addresses = addresses
    }
    
    /// Initialize from dictionary (for parsing JS returned data)
    public init?(from dictionary: [String: Any]) {
        guard let network = dictionary["network"] as? String,
              let privateKey = dictionary["privateKey"] as? String,
              let publicKey = dictionary["publicKey"] as? String,
              let addressesDict = dictionary["addresses"] as? [String: Any],
              let addresses = BitcoinAddresses(from: addressesDict) else {
            return nil
        }
        
        self.network = network
        self.mnemonicLength = dictionary["mnemonicLength"] as? Int
        self.mnemonic = dictionary["mnemonic"] as? String
        self.privateKey = privateKey
        self.publicKey = publicKey
        self.addresses = addresses
    }
    
    /// Get preferred address (prioritize segwit, then legacy, finally taproot)
    public var preferredAddress: String {
        if !addresses.segwit.isEmpty {
            return addresses.segwit
        } else if !addresses.legacy.isEmpty {
            return addresses.legacy
        } else {
            return addresses.taproot
        }
    }
    
    /// Convert to JSON string
    public func toJSONString() -> String? {
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        
        do {
            let data = try encoder.encode(self)
            return String(data: data, encoding: .utf8)
        } catch {
            return nil
        }
    }
    
    /// Initialize from JSON string
    public static func fromJSONString(_ jsonString: String) -> BitcoinWallet_V1? {
        guard let data = jsonString.data(using: .utf8) else {
            return nil
        }
        
        let decoder = JSONDecoder()
        do {
            return try decoder.decode(BitcoinWallet_V1.self, from: data)
        } catch {
            return nil
        }
    }
}

extension Bitcoin_V1: WKNavigationDelegate {
    public func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        if self.showLog { print("didFinish") }
    }

    public func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
        if self.showLog { print("error = \(error)") }
    }

    public func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
        if self.showLog { print("didStartProvisionalNavigation ") }
    }
}

public class Bitcoin_V1: NSObject {
    var webView: WKWebView!
    var bridge: BTCWebViewJavascriptBridge!
    public var isSuccess: Bool = false
    var onCompleted: ((Bool) -> Void)?
    var showLog: Bool = true
    override public init() {
        super.init()
        self.webView = WKWebView(frame: .zero, configuration: WKWebViewConfiguration())
        self.webView.navigationDelegate = self
        self.webView.configuration.preferences.setValue(true, forKey: "allowFileAccessFromFileURLs")
        self.bridge = BTCWebViewJavascriptBridge(webView: self.webView,isHookConsole: true)
    }

    deinit {
        print("\(type(of: self)) release")
    }

    public func setup(showLog: Bool = true,onCompleted: ((Bool) -> Void)? = nil) {
        self.onCompleted = onCompleted
        self.showLog = showLog
        #if !DEBUG
        self.showLog = false
        #endif
        self.bridge.register(handlerName: "generateBitcoin") { [weak self] _, _ in
            guard let self = self else { return }
            self.isSuccess = true
            self.onCompleted?(true)
        }

        self.bridge.consolePipeClosure = { logMessage in
            if self.showLog {
                print(logMessage ?? "")
            }
        }
        
        if let url = ResourceLoader_V1.url(name: "index", ext: "html", subdirectory: "Bitcoin_alpha.bundle") {
            self.webView.loadFileURL(url, allowingReadAccessTo: url)
        }
    }


    // MARK: createAccount
    /// Generate wallet account
    /// - Parameters:
    ///   - mnemonicLength: Mnemonic length (128/160/192/224/256, corresponding to 12/15/18/21/24 words), default 128
    ///   - isTestnet: Whether to use testnet, default true
    ///   - language: Mnemonic language ("english", "chinese_simplified", "chinese_traditional", "korean", "japanese", "french", "italian", "spanish", "czech", "portuguese"), default "english"
    ///   - onCompleted: Completion callback with parameters (success, wallet, errorMessage)
    ///                   success: Whether wallet generation succeeded
    ///                   wallet: Wallet information (non-nil on success, nil on failure)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    public func createAccount(mnemonicLength: Int = 128, isTestnet: Bool = true, language: String = "english", onCompleted: ((Bool, BitcoinWallet_V1?, String?) -> Void)? = nil) {
        let params: [String: Any] = [
            "mnemonicLength": mnemonicLength,
            "isTestnet": isTestnet,
            "language": language
        ]
        
        self.bridge.call(handlerName: "GenerateWallet", data: params) { response in
            if self.showLog { 
                print("GenerateWallet response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }

            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                // Handle error case
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using BitcoinWallet_V1 struct
            guard let wallet = BitcoinWallet_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse wallet data from response")
                return
            }
            
            // Return success
            onCompleted?(true, wallet, nil)
        }
    }
    
    // MARK: - Async/Await version of createAccount
    /// Create wallet account using async/await
    /// - Parameters:
    ///   - mnemonicLength: Mnemonic length in bits (128/160/192/224/256, default: 128)
    ///   - isTestnet: Whether to use testnet (default: true)
    ///   - language: Mnemonic language (default: "english")
    /// - Returns: Tuple containing (success: Bool, wallet: BitcoinWallet_V1?, error: String?)
    @available(iOS 13.0, *)
    public func createAccount(mnemonicLength: Int = 128, isTestnet: Bool = true, language: String = "english") async -> (Bool, BitcoinWallet_V1?, String?) {
        return await withCheckedContinuation { continuation in
            createAccount(mnemonicLength: mnemonicLength, isTestnet: isTestnet, language: language) { success, wallet, error in
                continuation.resume(returning: (success, wallet, error))
            }
        }
    }
    
    // MARK: importAccountFromMnemonic
    /// Import wallet account from mnemonic
    /// - Parameters:
    ///   - mnemonic: Mnemonic string (12 or 24 words)
    ///   - isTestnet: Whether to use testnet, default true
    ///   - language: Mnemonic language (optional, will auto-detect if not provided)
    ///   - onCompleted: Completion callback with parameters (success, wallet, errorMessage)
    ///                   success: Whether wallet import succeeded
    ///                   wallet: Wallet information (non-nil on success, nil on failure)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    public func importAccountFromMnemonic(mnemonic: String, isTestnet: Bool = true, language: String? = nil, onCompleted: ((Bool, BitcoinWallet_V1?, String?) -> Void)? = nil) {
        var params: [String: Any] = [
            "mnemonic": mnemonic,
            "isTestnet": isTestnet
        ]
        
        if let language = language {
            params["language"] = language
        }

        self.bridge.call(handlerName: "ImportWalletFromMnemonic", data: params) { response in
            if self.showLog { 
                print("ImportWalletFromMnemonic response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using BitcoinWallet_V1 struct
            guard let wallet = BitcoinWallet_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse wallet data from response")
                return
            }
            
            // Return success
            onCompleted?(true, wallet, nil)
        }
    }
    
    // MARK: - Async/Await version of importAccountFromMnemonic
    /// Import wallet account from mnemonic using async/await
    /// - Parameters:
    ///   - mnemonic: Mnemonic string (12 or 24 words)
    ///   - isTestnet: Whether to use testnet (default: true)
    ///   - language: Mnemonic language (optional)
    /// - Returns: Tuple containing (success: Bool, wallet: BitcoinWallet_V1?, error: String?)
    @available(iOS 13.0, *)
    public func importAccountFromMnemonic(mnemonic: String, isTestnet: Bool = true, language: String? = nil) async -> (Bool, BitcoinWallet_V1?, String?) {
        return await withCheckedContinuation { continuation in
            importAccountFromMnemonic(mnemonic: mnemonic, isTestnet: isTestnet, language: language) { success, wallet, error in
                continuation.resume(returning: (success, wallet, error))
            }
        }
    }
    
    // MARK: importAccountFromPrivateKey
    /// Import wallet account from private key
    /// - Parameters:
    ///   - privateKey: Private key string (64 hexadecimal characters)
    ///   - isTestnet: Whether to use testnet, default true
    ///   - onCompleted: Completion callback with parameters (success, wallet, errorMessage)
    ///                   success: Whether wallet import succeeded
    ///                   wallet: Wallet information (non-nil on success, nil on failure)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    ///                   wallet.mnemonic is nil when importing from private key
    public func importAccountFromPrivateKey(privateKey: String, isTestnet: Bool = true, onCompleted: ((Bool, BitcoinWallet_V1?, String?) -> Void)? = nil) {
        let params: [String: Any] = [
            "privateKey": privateKey,
            "isTestnet": isTestnet
        ]
        
        self.bridge.call(handlerName: "ImportWalletFromPrivateKey", data: params) { response in
            if self.showLog { 
                print("ImportWalletFromPrivateKey response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using BitcoinWallet_V1 struct
            guard let wallet = BitcoinWallet_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse wallet data from response")
                return
            }
            
            // Return success
            onCompleted?(true, wallet, nil)
        }
    }
    
    // MARK: - Async/Await version of importAccountFromPrivateKey
    /// Import wallet account from private key using async/await
    /// - Parameters:
    ///   - privateKey: Private key (Hex format, 64 characters)
    ///   - isTestnet: Whether to use testnet (default: true)
    /// - Returns: Tuple containing (success: Bool, wallet: BitcoinWallet_V1?, error: String?)
    @available(iOS 13.0, *)
    public func importAccountFromPrivateKey(privateKey: String, isTestnet: Bool = true) async -> (Bool, BitcoinWallet_V1?, String?) {
        return await withCheckedContinuation { continuation in
            importAccountFromPrivateKey(privateKey: privateKey, isTestnet: isTestnet) { success, wallet, error in
                continuation.resume(returning: (success, wallet, error))
            }
        }
    }
    
    // MARK: queryUTXO
    /// Query UTXO list for an address
    /// - Parameters:
    ///   - address: Bitcoin address
    ///   - isTestnet: Whether to use testnet, default true
    ///   - onCompleted: Completion callback with parameters (success, utxos, errorMessage)
    ///                   success: Whether query succeeded
    ///                   utxos: UTXO list (non-nil on success, nil on failure)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    public func queryUTXO(address: String, isTestnet: Bool = true, onCompleted: ((Bool, [[String: Any]]?, String?) -> Void)? = nil) {
        let params: [String: Any] = [
            "address": address,
            "isTestnet": isTestnet
        ]
        
        self.bridge.call(handlerName: "QueryUTXO", data: params) { response in
            if self.showLog {
                print("QueryUTXO response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: [...], error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data array
            guard let data = temp["data"] as? [[String: Any]] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }
            
            // Return success
            onCompleted?(true, data, nil)
        }
    }
    
    // MARK: - Async/Await version of queryUTXO
    /// Query UTXO using async/await
    /// - Parameters:
    ///   - address: Bitcoin address string
    ///   - isTestnet: Whether to use testnet (default: true)
    /// - Returns: Tuple containing (success: Bool, utxos: [[String: Any]]?, error: String?)
    @available(iOS 13.0, *)
    public func queryUTXO(address: String, isTestnet: Bool = true) async -> (Bool, [[String: Any]]?, String?) {
        return await withCheckedContinuation { continuation in
            queryUTXO(address: address, isTestnet: isTestnet) { success, utxos, error in
                continuation.resume(returning: (success, utxos, error))
            }
        }
    }
    
    // MARK: validateAddress
    /// Validate Bitcoin address
    /// - Parameters:
    ///   - address: Bitcoin address string
    ///   - onCompleted: Completion callback with parameters (success, result, errorMessage)
    ///                   success: Whether validation request succeeded
    ///                   result: Validation result (non-nil on success, nil on failure)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    public func validateAddress(address: String, onCompleted: ((Bool, AddressValidationResult_V1?, String?) -> Void)? = nil) {
        let params: [String: Any] = [
            "address": address
        ]
        
        self.bridge.call(handlerName: "ValidateAddress", data: params) { response in
            if self.showLog {
                print("ValidateAddress response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using AddressValidationResult_V1 struct
            guard let result = AddressValidationResult_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse validation result from response")
                return
            }
            
            // Return success
            onCompleted?(true, result, nil)
        }
    }
    
    // MARK: - Async/Await version of validateAddress
    /// Validate Bitcoin address using async/await
    /// - Parameters:
    ///   - address: Bitcoin address string
    /// - Returns: Tuple containing (success: Bool, result: AddressValidationResult_V1?, error: String?)
    @available(iOS 13.0, *)
    public func validateAddress(address: String) async -> (Bool, AddressValidationResult_V1?, String?) {
        return await withCheckedContinuation { continuation in
            validateAddress(address: address) { success, result, error in
                continuation.resume(returning: (success, result, error))
            }
        }
    }
    
    // MARK: oneClickTransfer
    /// One-click transfer (automatically fetch balance from network, sign and send)
    /// - Parameters:
    ///   - privKeyHex: Private key (HEX format)
    ///   - toAddress: Recipient address
    ///   - amountSats: Transfer amount (satoshis)
    ///   - feeSats: Fee (satoshis)
    ///   - isTestnet: Whether to use testnet, default true
    ///   - fromAddress: Optional: Sender address (if not provided, defaults to Segwit address)
    ///   - onCompleted: Completion callback with parameters (success, result, errorMessage)
    ///                   success: Whether transfer request succeeded
    ///                   result: Transfer result (non-nil on success, nil on failure)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    public func oneClickTransfer(privKeyHex: String, toAddress: String, amountSats: Int64, feeSats: Int64, isTestnet: Bool = true, fromAddress: String? = nil, onCompleted: ((Bool, OneClickTransferResult_V1?, String?) -> Void)? = nil) {
        var params: [String: Any] = [
            "privKeyHex": privKeyHex,
            "toAddress": toAddress,
            "amountSats": amountSats,
            "feeSats": feeSats,
            "isTestnet": isTestnet
        ]
        
        // If sender address is provided, add it to parameters
        if let fromAddress = fromAddress, !fromAddress.isEmpty {
            params["fromAddress"] = fromAddress
        }
        
        self.bridge.call(handlerName: "OneClickTransfer", data: params) { response in
            if self.showLog {
                print("OneClickTransfer response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using OneClickTransferResult_V1 struct
            guard let result = OneClickTransferResult_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse transfer result from response")
                return
            }
            
            // Return success
            onCompleted?(true, result, nil)
        }
    }
    
    // MARK: - Async/Await version of oneClickTransfer
    /// One-click transfer using async/await
    /// - Parameters:
    ///   - privKeyHex: Private key (Hex)
    ///   - toAddress: Recipient address
    ///   - amountSats: Transfer amount in satoshis
    ///   - feeSats: Fee in satoshis
    ///   - isTestnet: Whether to use testnet (default: true)
    ///   - fromAddress: Optional source address
    /// - Returns: Tuple containing (success: Bool, result: OneClickTransferResult_V1?, error: String?)
    @available(iOS 13.0, *)
    public func oneClickTransfer(privKeyHex: String, toAddress: String, amountSats: Int64, feeSats: Int64, isTestnet: Bool = true, fromAddress: String? = nil) async -> (Bool, OneClickTransferResult_V1?, String?) {
        return await withCheckedContinuation { continuation in
            oneClickTransfer(privKeyHex: privKeyHex, toAddress: toAddress, amountSats: amountSats, feeSats: feeSats, isTestnet: isTestnet, fromAddress: fromAddress) { success, result, error in
                continuation.resume(returning: (success, result, error))
            }
        }
    }
    
    // MARK: batchTransfer
    /// Batch transfer: Create and sign batch transfer transaction (online method, automatically queries UTXO)
    /// - Parameters:
    ///   - outputs: Recipient list [{ address: String, value: Int64 }]
    ///   - feeSats: Total fee (satoshis)
    ///   - privKeyHex: Private key (HEX format)
    ///   - isTestnet: Whether to use testnet
    ///   - fromAddress: Optional: Sender address (if not provided, will derive Segwit address from private key)
    ///   - onCompleted: Completion callback with parameters (success, result, errorMessage)
    ///                   success: Whether creation request succeeded
    ///                   result: Creation result (non-nil on success, contains signedHex)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    public func batchTransfer(outputs: [[String: Any]], feeSats: Int64, privKeyHex: String, isTestnet: Bool, fromAddress: String?, onCompleted: ((Bool, BatchTransferResult_V1?, String?) -> Void)? = nil) {
        var params: [String: Any] = [
            "outputs": outputs,
            "feeSats": feeSats,
            "privKeyHex": privKeyHex,
            "isTestnet": isTestnet
        ]
        if let fromAddress = fromAddress, !fromAddress.isEmpty {
            params["fromAddress"] = fromAddress
        }
        
        self.bridge.call(handlerName: "BatchTransfer", data: params) { response in
            if self.showLog {
                print("BatchTransfer response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using BatchTransferResult_V1 struct
            guard let result = BatchTransferResult_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse batch transfer result from response")
                return
            }
            
            // Return success
            onCompleted?(true, result, nil)
        }
    }
    
    // MARK: - Async/Await version of batchTransfer
    /// Batch transfer using async/await
    /// - Parameters:
    ///   - outputs: Array of output dictionaries [{"address": "...", "amount": ...}]
    ///   - feeSats: Fee in satoshis
    ///   - privKeyHex: Private key (Hex)
    ///   - isTestnet: Whether to use testnet
    ///   - fromAddress: Optional source address
    /// - Returns: Tuple containing (success: Bool, result: BatchTransferResult_V1?, error: String?)
    @available(iOS 13.0, *)
    public func batchTransfer(outputs: [[String: Any]], feeSats: Int64, privKeyHex: String, isTestnet: Bool, fromAddress: String?) async -> (Bool, BatchTransferResult_V1?, String?) {
        return await withCheckedContinuation { continuation in
            batchTransfer(outputs: outputs, feeSats: feeSats, privKeyHex: privKeyHex, isTestnet: isTestnet, fromAddress: fromAddress) { success, result, error in
                continuation.resume(returning: (success, result, error))
            }
        }
    }
    
    // MARK: estimateFee
    /// Estimate fee
    /// - Parameters:
    ///   - inputsCount: Number of inputs (UTXO count), default 1
    ///   - outputsCount: Number of outputs (recipient address + change address), default 2
    ///   - isTestnet: Whether to use testnet, default true
    ///   - addressType: Address type ('legacy' | 'segwit' | 'taproot'), default 'segwit'
    ///   - onCompleted: Completion callback with parameters (success, result, errorMessage)
    ///                   success: Whether estimation request succeeded
    ///                   result: Estimation result (non-nil on success, nil on failure)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    public func estimateFee(inputsCount: Int = 1, outputsCount: Int = 2, isTestnet: Bool = true, addressType: String = "segwit", n: Int = 1, m: Int = 1, onCompleted: ((Bool, FeeEstimateResult_V1?, String?) -> Void)? = nil) {
        var params: [String: Any] = [
            "inputsCount": inputsCount,
            "outputsCount": outputsCount,
            "isTestnet": isTestnet,
            "addressType": addressType
        ]
        
        // 如果是多签类型，添加 n 和 m 参数
        if addressType == "multisig" {
            params["n"] = n
            params["m"] = m
        }
        
        self.bridge.call(handlerName: "EstimateFee", data: params) { response in
            if self.showLog {
                print("EstimateFee response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using FeeEstimateResult_V1 struct
            guard let result = FeeEstimateResult_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse fee estimate result from response")
                return
            }
            
            // Return success
            onCompleted?(true, result, nil)
        }
    }
    
    // MARK: - Async/Await version of estimateFee
    /// Estimate fee using async/await
    /// - Parameters:
    ///   - inputsCount: Number of inputs (UTXO count), default 1
    ///   - outputsCount: Number of outputs (recipient address + change address), default 2
    ///   - isTestnet: Whether to use testnet, default true
    ///   - addressType: Address type ('legacy' | 'segwit' | 'taproot'), default 'segwit'
    ///   - n: Multisig threshold (for multisig only), default 1
    ///   - m: Multisig total signers (for multisig only), default 1
    /// - Returns: Tuple containing (success: Bool, result: FeeEstimateResult_V1?, error: String?)
    @available(iOS 13.0, *)
    public func estimateFee(inputsCount: Int = 1, outputsCount: Int = 2, isTestnet: Bool = true, addressType: String = "segwit", n: Int = 1, m: Int = 1) async -> (Bool, FeeEstimateResult_V1?, String?) {
        return await withCheckedContinuation { continuation in
            estimateFee(inputsCount: inputsCount, outputsCount: outputsCount, isTestnet: isTestnet, addressType: addressType, n: n, m: m) { success, result, error in
                continuation.resume(returning: (success, result, error))
            }
        }
    }
    
    // MARK: generateHtlcAddress
    /// Generate HTLC address (single signature, non-Taproot)
    /// - Parameters:
    ///   - pubkey: Public key (HEX format, 66-character compressed public key)
    ///   - lockHeight: Lock height
    ///   - secretHex: Secret preimage (HEX format)
    ///   - isTestnet: Whether to use testnet, default true
    ///   - onCompleted: Completion callback with parameters (success, result, errorMessage)
    ///                   success: Whether generation request succeeded
    ///                   result: Generation result (non-nil on success, contains address, redeemScript, lockHeight, secretHex)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    public func generateHtlcAddress(pubkey: String, lockHeight: Int, secretHex: String, isTestnet: Bool = true, onCompleted: ((Bool, HTLCAddressResult_V1?, String?) -> Void)? = nil) {
        let params: [String: Any] = [
            "pubkey": pubkey,
            "lockHeight": lockHeight,
            "secretHex": secretHex,
            "isTestnet": isTestnet
        ]
        
        self.bridge.call(handlerName: "GenerateHTLCAddress", data: params) { response in
            if self.showLog {
                print("GenerateHTLCAddress response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using HTLCAddressResult_V1 struct
            guard let result = HTLCAddressResult_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse HTLC address result from response")
                return
            }
            
            // Return success
            onCompleted?(true, result, nil)
        }
    }
    
    // MARK: - Async/Await version of generateHtlcAddress
    /// Generate HTLC address using async/await
    /// - Parameters:
    ///   - pubkey: Public key (Hex format, 66-character compressed public key)
    ///   - lockHeight: Lock height
    ///   - secretHex: Secret preimage (Hex format)
    ///   - isTestnet: Whether to use testnet (default: true)
    /// - Returns: Tuple containing (success: Bool, result: HTLCAddressResult_V1?, error: String?)
    @available(iOS 13.0, *)
    public func generateHtlcAddress(pubkey: String, lockHeight: Int, secretHex: String, isTestnet: Bool = true) async -> (Bool, HTLCAddressResult_V1?, String?) {
        return await withCheckedContinuation { continuation in
            generateHtlcAddress(pubkey: pubkey, lockHeight: lockHeight, secretHex: secretHex, isTestnet: isTestnet) { success, result, error in
                continuation.resume(returning: (success, result, error))
            }
        }
    }
    
    // MARK: unlockHtlcAddress
    /// Unlock HTLC address and transfer (single signature, non-Taproot)
    /// - Parameters:
    ///   - htlcAddress: HTLC source address (P2WSH)
    ///   - toAddress: Recipient address
    ///   - amountSats: Transfer amount (satoshis)
    ///   - feeSats: Fee (satoshis)
    ///   - privKeyHex: Private key (HEX format)
    ///   - lockHeight: Lock height
    ///   - secretHex: Secret preimage (HEX format)
    ///   - redeemScript: Redeem script (HEX format)
    ///   - isTestnet: Whether to use testnet, default true
    ///   - onCompleted: Completion callback with parameters (success, result, errorMessage)
    ///                   success: Whether unlock request succeeded
    ///                   result: Unlock result (non-nil on success, contains txid and signedHex)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    public func unlockHtlcAddress(htlcAddress: String, toAddress: String, amountSats: Int64, feeSats: Int64, privKeyHex: String, lockHeight: Int, secretHex: String, redeemScript: String, isTestnet: Bool = true, onCompleted: ((Bool, HTLCUnlockResult_V1?, String?) -> Void)? = nil) {
        let params: [String: Any] = [
            "htlcAddress": htlcAddress,
            "toAddress": toAddress,
            "amountSats": amountSats,
            "feeSats": feeSats,
            "privKeyHex": privKeyHex,
            "lockHeight": lockHeight,
            "secretHex": secretHex,
            "redeemScript": redeemScript,
            "isTestnet": isTestnet
        ]
        
        self.bridge.call(handlerName: "HTLCUnlock", data: params) { response in
            if self.showLog {
                print("HTLCUnlock response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using HTLCUnlockResult_V1 struct
            guard let result = HTLCUnlockResult_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse HTLC unlock result from response")
                return
            }
            
            // Return success
            onCompleted?(true, result, nil)
        }
    }
    
    // MARK: - Async/Await version of unlockHtlcAddress
    /// Unlock HTLC address and transfer using async/await
    /// - Parameters:
    ///   - htlcAddress: HTLC source address (P2WSH)
    ///   - toAddress: Recipient address
    ///   - amountSats: Transfer amount in satoshis
    ///   - feeSats: Fee in satoshis
    ///   - privKeyHex: Private key (Hex)
    ///   - lockHeight: Lock height
    ///   - secretHex: Secret preimage (Hex)
    ///   - redeemScript: Redeem script (Hex)
    ///   - isTestnet: Whether to use testnet (default: true)
    /// - Returns: Tuple containing (success: Bool, result: HTLCUnlockResult_V1?, error: String?)
    @available(iOS 13.0, *)
    public func unlockHtlcAddress(htlcAddress: String, toAddress: String, amountSats: Int64, feeSats: Int64, privKeyHex: String, lockHeight: Int, secretHex: String, redeemScript: String, isTestnet: Bool = true) async -> (Bool, HTLCUnlockResult_V1?, String?) {
        return await withCheckedContinuation { continuation in
            unlockHtlcAddress(htlcAddress: htlcAddress, toAddress: toAddress, amountSats: amountSats, feeSats: feeSats, privKeyHex: privKeyHex, lockHeight: lockHeight, secretHex: secretHex, redeemScript: redeemScript, isTestnet: isTestnet) { success, result, error in
                continuation.resume(returning: (success, result, error))
            }
        }
    }
    
    // MARK: generateNoSigScriptAddress
    /// Generate no-signature script address (TimeLock + HashLock, no signature required)
    /// - Parameters:
    ///   - lockHeight: Lock height
    ///   - secretHex: Secret preimage (HEX format)
    ///   - isTestnet: Whether to use testnet, default true
    ///   - onCompleted: Completion callback with parameters (success, result, errorMessage)
    ///                   success: Whether generation request succeeded
    ///                   result: Generation result (non-nil on success, contains address, redeemScript, lockHeight, secretHex)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    /// - Note: No-signature script means anyone who knows the preimage can spend the funds. Please ensure the preimage remains secret until unlock conditions are met.
    public func generateNoSigScriptAddress(lockHeight: Int, secretHex: String, isTestnet: Bool = true, onCompleted: ((Bool, HTLCAddressResult_V1?, String?) -> Void)? = nil) {
        let params: [String: Any] = [
            "lockHeight": lockHeight,
            "secretHex": secretHex,
            "isTestnet": isTestnet
        ]
        
        self.bridge.call(handlerName: "GenerateNoSigScriptAddress", data: params) { response in
            if self.showLog {
                print("GenerateNoSigScriptAddress response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using HTLCAddressResult_V1 struct (same fields)
            guard let result = HTLCAddressResult_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse no-sig script address result from response")
                return
            }
            
            // Return success
            onCompleted?(true, result, nil)
        }
    }
    
    // MARK: - Async/Await version of generateNoSigScriptAddress
    /// Generate no-signature script address using async/await
    /// - Parameters:
    ///   - lockHeight: Lock height
    ///   - secretHex: Secret preimage (Hex format)
    ///   - isTestnet: Whether to use testnet (default: true)
    /// - Returns: Tuple containing (success: Bool, result: HTLCAddressResult_V1?, error: String?)
    @available(iOS 13.0, *)
    public func generateNoSigScriptAddress(lockHeight: Int, secretHex: String, isTestnet: Bool = true) async -> (Bool, HTLCAddressResult_V1?, String?) {
        return await withCheckedContinuation { continuation in
            generateNoSigScriptAddress(lockHeight: lockHeight, secretHex: secretHex, isTestnet: isTestnet) { success, result, error in
                continuation.resume(returning: (success, result, error))
            }
        }
    }
    
    // MARK: unlockNoSigScriptAddress
    /// Unlock no-signature script address and transfer (no signature required, only preimage needed)
    /// - Parameters:
    ///   - noSigAddress: No-signature script source address (P2WSH)
    ///   - toAddress: Recipient address
    ///   - amountSats: Transfer amount (satoshis)
    ///   - feeSats: Fee (satoshis)
    ///   - lockHeight: Lock height
    ///   - secretHex: Secret preimage (HEX format)
    ///   - redeemScript: Redeem script (HEX format)
    ///   - isTestnet: Whether to use testnet, default true
    ///   - changeAddress: Optional change address. If not provided, change will be sent to toAddress (not recommended)
    ///   - onCompleted: Completion callback with parameters (success, result, errorMessage)
    ///                   success: Whether unlock request succeeded
    ///                   result: Unlock result (non-nil on success, contains txid and signedHex)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    /// - Note: No-signature script unlock does not require private key or signature, only the preimage
    public func unlockNoSigScriptAddress(noSigAddress: String, toAddress: String, amountSats: Int64, feeSats: Int64, lockHeight: Int, secretHex: String, redeemScript: String, isTestnet: Bool = true, changeAddress: String? = nil, onCompleted: ((Bool, HTLCUnlockResult_V1?, String?) -> Void)? = nil) {
        var params: [String: Any] = [
            "noSigAddress": noSigAddress,
            "toAddress": toAddress,
            "amountSats": amountSats,
            "feeSats": feeSats,
            "lockHeight": lockHeight,
            "secretHex": secretHex,
            "redeemScript": redeemScript,
            "isTestnet": isTestnet
        ]
        
        
        if let changeAddress = changeAddress {
            params["changeAddress"] = changeAddress
        }
        
        self.bridge.call(handlerName: "NoSigScriptUnlock", data: params) { response in
            if self.showLog {
                print("NoSigScriptUnlock response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using HTLCUnlockResult_V1 struct (same fields)
            guard let result = HTLCUnlockResult_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse no-sig script unlock result from response")
                return
            }
            
            // Return success
            onCompleted?(true, result, nil)
        }
    }
    
    // MARK: - Async/Await version of unlockNoSigScriptAddress
    /// Unlock no-signature script address and transfer using async/await
    /// - Parameters:
    ///   - noSigAddress: No-signature script source address (P2WSH)
    ///   - toAddress: Recipient address
    ///   - amountSats: Transfer amount in satoshis
    ///   - feeSats: Fee in satoshis
    ///   - lockHeight: Lock height
    ///   - secretHex: Secret preimage (Hex)
    ///   - redeemScript: Redeem script (Hex)
    ///   - isTestnet: Whether to use testnet (default: true)
    ///   - changeAddress: Optional change address. If not provided, change will be sent to toAddress (not recommended)
    /// - Returns: Tuple containing (success: Bool, result: HTLCUnlockResult_V1?, error: String?)
    @available(iOS 13.0, *)
    public func unlockNoSigScriptAddress(noSigAddress: String, toAddress: String, amountSats: Int64, feeSats: Int64, lockHeight: Int, secretHex: String, redeemScript: String, isTestnet: Bool = true, changeAddress: String? = nil) async -> (Bool, HTLCUnlockResult_V1?, String?) {
        return await withCheckedContinuation { continuation in
            unlockNoSigScriptAddress(noSigAddress: noSigAddress, toAddress: toAddress, amountSats: amountSats, feeSats: feeSats, lockHeight: lockHeight, secretHex: secretHex, redeemScript: redeemScript, isTestnet: isTestnet, changeAddress: changeAddress) { success, result, error in
                continuation.resume(returning: (success, result, error))
            }
        }
    }
    
    // MARK: generateMultisigAddress
    /// Generate multisig address (non-Taproot address, generates P2SH and P2WSH addresses)
    /// - Parameters:
    ///   - threshold: Threshold number (Threshold N)
    ///   - pubkeys: Public key list (array)
    ///   - isTestnet: Whether to use testnet, default true
    ///   - onCompleted: Completion callback with parameters (success, result, errorMessage)
    ///                   success: Whether generation request succeeded
    ///                   result: Generation result (non-nil on success, contains script, p2shAddress, p2wshAddress, threshold, totalSigners)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    public func generateMultisigAddress(threshold: Int, pubkeys: [String], isTestnet: Bool = true, onCompleted: ((Bool, MultisigAddressResult_V1?, String?) -> Void)? = nil) {
        let params: [String: Any] = [
            "threshold": threshold,
            "pubkeys": pubkeys,
            "isTestnet": isTestnet
        ]
        
        self.bridge.call(handlerName: "GenerateMultisigAddress", data: params) { response in
            if self.showLog {
                print("GenerateMultisigAddress response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using MultisigAddressResult_V1 struct
            guard let result = MultisigAddressResult_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse multisig address result from response")
                return
            }
            
            // Return success
            onCompleted?(true, result, nil)
        }
    }
    
    // MARK: - Async/Await version of generateMultisigAddress
    /// Generate multisig address using async/await
    /// - Parameters:
    ///   - threshold: Threshold (N in N-of-M)
    ///   - pubkeys: Array of public keys (M total)
    ///   - isTestnet: Whether to use testnet (default: true)
    /// - Returns: Tuple containing (success: Bool, result: MultisigAddressResult_V1?, error: String?)
    @available(iOS 13.0, *)
    public func generateMultisigAddress(threshold: Int, pubkeys: [String], isTestnet: Bool = true) async -> (Bool, MultisigAddressResult_V1?, String?) {
        return await withCheckedContinuation { continuation in
            generateMultisigAddress(threshold: threshold, pubkeys: pubkeys, isTestnet: isTestnet) { success, result, error in
                continuation.resume(returning: (success, result, error))
            }
        }
    }
    
    // MARK: sendMultisigTransaction
    /// Execute multisig transfer (create, sign and broadcast)
    /// - Parameters:
    ///   - multisigAddress: Multisig address
    ///   - toAddress: Recipient address
    ///   - amountSats: Transfer amount (satoshis)
    ///   - feeSats: Fee (satoshis)
    ///   - allPubkeys: All participant public key array (order must be correct)
    ///   - signPrivKeys: Private key array for signing (must meet threshold number)
    ///   - isTestnet: Whether to use testnet, default true
    ///   - onCompleted: Completion callback with parameters (success, result, errorMessage)
    ///                   success: Whether transfer request succeeded
    ///                   result: Transfer result (non-nil on success, contains txid, signedHex)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    public func sendMultisigTransaction(multisigAddress: String, toAddress: String, amountSats: Int64, feeSats: Int64, allPubkeys: [String], signPrivKeys: [String], isTestnet: Bool = true, onCompleted: ((Bool, MultisigTransferResult_V1?, String?) -> Void)? = nil) {
        let params: [String: Any] = [
            "multisigAddress": multisigAddress,
            "toAddress": toAddress,
            "amountSats": amountSats,
            "feeSats": feeSats,
            "allPubkeys": allPubkeys,
            "signPrivKeys": signPrivKeys,
            "isTestnet": isTestnet
        ]
        
        self.bridge.call(handlerName: "SendMultisigTransaction", data: params) { response in
            if self.showLog {
                print("SendMultisigTransaction response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            // JS response format: { success: Bool, data: {...}, error: String? }
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            // Extract data object
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            // Parse data using MultisigTransferResult_V1 struct
            guard let result = MultisigTransferResult_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse multisig transfer result from response")
                return
            }
            
            // Return success
            onCompleted?(true, result, nil)
        }
    }
    
    // MARK: - Async/Await version of sendMultisigTransaction
    /// Execute multisig transfer using async/await
    /// - Parameters:
    ///   - multisigAddress: Multisig address
    ///   - toAddress: Recipient address
    ///   - amountSats: Transfer amount in satoshis
    ///   - feeSats: Fee in satoshis
    ///   - allPubkeys: All public keys (M total)
    ///   - signPrivKeys: Private keys for signing (must meet threshold N)
    ///   - isTestnet: Whether to use testnet (default: true)
    /// - Returns: Tuple containing (success: Bool, result: MultisigTransferResult_V1?, error: String?)
    @available(iOS 13.0, *)
    public func sendMultisigTransaction(multisigAddress: String, toAddress: String, amountSats: Int64, feeSats: Int64, allPubkeys: [String], signPrivKeys: [String], isTestnet: Bool = true) async -> (Bool, MultisigTransferResult_V1?, String?) {
        return await withCheckedContinuation { continuation in
            sendMultisigTransaction(multisigAddress: multisigAddress, toAddress: toAddress, amountSats: amountSats, feeSats: feeSats, allPubkeys: allPubkeys, signPrivKeys: signPrivKeys, isTestnet: isTestnet) { success, result, error in
                continuation.resume(returning: (success, result, error))
            }
        }
    }
    
    // MARK: generateTimeLockScript
    /// Generate time lock script (for Tapscript)
    /// - Parameters:
    ///   - lockHeight: Lock height
    ///   - isTestnet: Whether to use testnet, default true
    ///   - onCompleted: Completion callback, returns script (Hex format)
    public func generateTimeLockScript(lockHeight: Int, isTestnet: Bool = true, onCompleted: ((Bool, String?, String?) -> Void)? = nil) {
        let params: [String: Any] = [
            "lockHeight": lockHeight,
            "isTestnet": isTestnet
        ]
        
        self.bridge.call(handlerName: "GenerateTimeLockScript", data: params) { response in
            if self.showLog {
                print("GenerateTimeLockScript response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            guard let script = temp["script"] as? String else {
                onCompleted?(false, nil, "Missing 'script' field in response")
                return
            }
            
            onCompleted?(true, script, nil)
        }
    }
    
    // MARK: generateHashLockScript
    /// Generate hash lock script (for Tapscript)
    /// - Parameters:
    ///   - secretHex: Preimage (Secret Hex)
    ///   - isTestnet: Whether to use testnet, default true
    ///   - onCompleted: Completion callback, returns script (Hex format)
    public func generateHashLockScript(secretHex: String, isTestnet: Bool = true, onCompleted: ((Bool, String?, String?) -> Void)? = nil) {
        let params: [String: Any] = [
            "secretHex": secretHex,
            "isTestnet": isTestnet
        ]
        
        self.bridge.call(handlerName: "GenerateHashLockScript", data: params) { response in
            if self.showLog {
                print("GenerateHashLockScript response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            guard let script = temp["script"] as? String else {
                onCompleted?(false, nil, "Missing 'script' field in response")
                return
            }
            
            onCompleted?(true, script, nil)
        }
    }
    
    // MARK: sendTapscriptTransaction
    /// Execute Tapscript unlock and transfer (create, sign and broadcast)
    /// - Parameters:
    ///   - tapscriptAddress: Tapscript address
    ///   - toAddress: Recipient address
    ///   - amountSats: Transfer amount (satoshis)
    ///   - feeSats: Fee (satoshis)
    ///   - scriptHex: Script to use (Hex)
    ///   - privKeyHex: Master key private key (Hex)
    ///   - schnorrPubkey: Schnorr public key (master key, Hex, no prefix)
    ///   - merkleRoot: Merkle root (Hex, nil if only one script)
    ///   - allScripts: All scripts list (for building Control Block)
    ///   - scriptParams: Script parameters (e.g., {secretHex: '...', lockHeight: 123})
    ///   - isTestnet: Whether to use testnet, default true
    ///   - tapTweakHex: Optional Tap Tweak (Hex)
    ///   - tapTweakedPubkeyHex: Optional tweaked public key (Hex)
    ///   - onCompleted: Completion callback
    public func sendTapscriptTransaction(tapscriptAddress: String, toAddress: String, amountSats: Int64, feeSats: Int64, scriptHex: String, privKeyHex: String, schnorrPubkey: String, merkleRoot: String?, allScripts: [String], scriptParams: [String: Any], isTestnet: Bool = true, tapTweakHex: String? = nil, tapTweakedPubkeyHex: String? = nil, onCompleted: ((Bool, HTLCUnlockResult_V1?, String?) -> Void)? = nil) {
        var params: [String: Any] = [
            "tapscriptAddress": tapscriptAddress,
            "toAddress": toAddress,
            "amountSats": amountSats,
            "feeSats": feeSats,
            "scriptHex": scriptHex,
            "privKeyHex": privKeyHex,
            "schnorrPubkey": schnorrPubkey,
            "allScripts": allScripts,
            "scriptParams": scriptParams,
            "isTestnet": isTestnet
        ]
        
        if let merkleRoot = merkleRoot {
            params["merkleRoot"] = merkleRoot
        }
        if let tapTweakHex = tapTweakHex {
            params["tapTweakHex"] = tapTweakHex
        }
        if let tapTweakedPubkeyHex = tapTweakedPubkeyHex {
            params["tapTweakedPubkeyHex"] = tapTweakedPubkeyHex
        }
        
        self.bridge.call(handlerName: "SendTapscriptTransaction", data: params) { response in
            if self.showLog {
                print("SendTapscriptTransaction response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, "Invalid response format")
                return
            }
            
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, errorMessage)
                return
            }
            
            guard let data = temp["data"] as? [String: Any] else {
                onCompleted?(false, nil, "Missing 'data' field in response")
                return
            }

            guard let result = HTLCUnlockResult_V1(from: data) else {
                onCompleted?(false, nil, "Failed to parse tapscript unlock result from response")
                return
            }
            
            onCompleted?(true, result, nil)
        }
    }
    
    // MARK: signMessage
    /// BIP322 message signing
    /// - Parameters:
    ///   - message: Message to sign
    ///   - privKeyHex: Private key (Hex format), if nil then use the wallet private key generated above
    ///   - addressType: Address type ("legacy", "segwit", "taproot")
    ///   - isTestnet: Whether to use testnet, default true
    ///   - onCompleted: Completion callback with parameters (success, address, signature, errorMessage)
    ///                   success: Whether signing request succeeded
    ///                   address: Address used (non-nil on success)
    ///                   signature: Signature (Base64 format, non-nil on success)
    ///                   errorMessage: Error message (nil on success, non-nil on failure)
    public func signMessage(message: String, privKeyHex: String?, addressType: String, isTestnet: Bool = true, onCompleted: ((Bool, String?, String?, String?) -> Void)? = nil) {
        var params: [String: Any] = [
            "message": message,
            "addressType": addressType,
            "isTestnet": isTestnet
        ]
        
        if let privKeyHex = privKeyHex {
            params["privKeyHex"] = privKeyHex
        }
        
        self.bridge.call(handlerName: "SignMessage", data: params) { response in
            if self.showLog {
                print("SignMessage response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, nil, nil, "Invalid response format")
                return
            }
            
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, nil, nil, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, nil, nil, errorMessage)
                return
            }
            
            guard let address = temp["address"] as? String,
                  let signature = temp["signature"] as? String else {
                onCompleted?(false, nil, nil, "Missing 'address' or 'signature' field in response")
                return
            }
            
            onCompleted?(true, address, signature, nil)
        }
    }
    
    // MARK: - Async/Await version of signMessage
    /// Sign message using async/await
    /// - Parameters:
    ///   - message: Message to sign
    ///   - privKeyHex: Private key (Hex, optional)
    ///   - addressType: Address type ('legacy' | 'segwit' | 'taproot')
    ///   - isTestnet: Whether to use testnet (default: true)
    /// - Returns: Tuple containing (success: Bool, address: String?, signature: String?, error: String?)
    @available(iOS 13.0, *)
    public func signMessage(message: String, privKeyHex: String?, addressType: String, isTestnet: Bool = true) async -> (Bool, String?, String?, String?) {
        return await withCheckedContinuation { continuation in
            signMessage(message: message, privKeyHex: privKeyHex, addressType: addressType, isTestnet: isTestnet) { success, address, signature, error in
                continuation.resume(returning: (success, address, signature, error))
            }
        }
    }
    
    // MARK: verifyMessage
    /// BIP322 message verification
    /// - Parameters:
    ///   - message: Original message
    ///   - signature: Signature (Base64 format)
    ///   - address: Address claimed by signer
    ///   - isTestnet: Whether to use testnet, default true
    ///   - onCompleted: Completion callback with parameters (success, isValid, errorMessage)
    ///                   success: Whether verification request succeeded
    ///                   isValid: Whether signature is valid (valid when success is true)
    ///                   errorMessage: Error message (nil when success is true)
    public func verifyMessage(message: String, signature: String, address: String, isTestnet: Bool = true, onCompleted: ((Bool, Bool, String?) -> Void)? = nil) {
        let params: [String: Any] = [
            "message": message,
            "signature": signature,
            "address": address,
            "isTestnet": isTestnet
        ]
        
        self.bridge.call(handlerName: "VerifyMessage", data: params) { response in
            if self.showLog {
                print("VerifyMessage response = \(String(describing: response))")
            }

            guard let temp = response as? [String: Any] else {
                onCompleted?(false, false, "Invalid response format")
                return
            }
            
            guard let success = temp["success"] as? Bool else {
                onCompleted?(false, false, "Missing 'success' field in response")
                return
            }
            
            if !success {
                let errorMessage = temp["error"] as? String ?? "Unknown error"
                onCompleted?(false, false, errorMessage)
                return
            }
            
            guard let isValid = temp["isValid"] as? Bool else {
                onCompleted?(false, false, "Missing 'isValid' field in response")
                return
            }
            
            onCompleted?(true, isValid, nil)
        }
    }
    
    // MARK: - Async/Await version of verifyMessage
    /// Verify message signature using async/await
    /// - Parameters:
    ///   - message: Original message
    ///   - signature: Signature to verify
    ///   - address: Address that should have signed the message
    ///   - isTestnet: Whether to use testnet (default: true)
    /// - Returns: Tuple containing (success: Bool, isValid: Bool, error: String?)
    @available(iOS 13.0, *)
    public func verifyMessage(message: String, signature: String, address: String, isTestnet: Bool = true) async -> (Bool, Bool, String?) {
        return await withCheckedContinuation { continuation in
            verifyMessage(message: message, signature: signature, address: address, isTestnet: isTestnet) { success, isValid, error in
                continuation.resume(returning: (success, isValid, error))
            }
        }
    }
}
